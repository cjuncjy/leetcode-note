# 打家劫舍

> 难度：中等  
> 地址：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/

## 题目描述

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

示例 1：

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

示例  2：

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

提示：

- 1 <= nums.length <= 100
- 0 <= nums[i] <= 400

---

## 题目解答

本题使用动态规划解法，首先我们来分析一下：

假设房屋的数量为 n，当 n=1 时，那么能偷到的最大的金额就是房屋所有金额；  
当 n=2 时，由于不能连续偷，那么最大金额就是在房屋 1 和房屋 2 中二选一；  
当 n=3 时，最大金额就是房屋 1 的金额+房屋 3 的金额，或者房屋 2 的金额，这两者取最大值。
当 n=4 时，能偷的选择就是第三间房屋能获取到的最大值，或者第一二间房屋的最大值(即 dp[2])和第四间房屋的金额的和，来进行比较
...

综合上面的分析，我们可以得出状态转移方程：
`dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]) ps: i >= 2`

基于这个方程，我们就可以去求算我们的结果。

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {
  // 边界判断
  if (nums.length === 1) {
    return nums[0];
  }
  // dp数组
  const dp = [];
  dp[0] = nums[0];
  dp[1] = Math.max(dp[0], nums[1]);

  for (let i = 2; i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
  }
  return dp[dp.length - 1];
};
```
