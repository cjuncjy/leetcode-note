# 分发饼干

> 难度：简单  
> 地址：https://leetcode-cn.com/problems/longest-palindrome/

## 题目描述

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值  g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。  
如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

示例 1：

```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释:
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
```

示例  2：

```
输入: g = [1,2], s = [1,2,3]
输出: 2
解释:
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```

提示：

- 1 <= g.length <= 3 \* 104
- 0 <= s.length <= 3 \* 104
- 1 <= g[i], s[j] <= 231 - 1

---

## 题目解答

本题使用排序+贪心，对孩子数组 g 和饼干数组 s 进行排序，对于 g 中的每一个孩子，将 s 中的每一块刚好大于 g 的饼干分配给孩子即可得到最大值。  
证明：  
若存在 `s[i] < g[j] < s[i+1] < g[j+1]`，此时将 `g[j]`给 `s[i]`，`g[j+1]`分配给 `s[i+1]`为最佳分配，若将 `g[j+1]`分配给 `s[i]`，则 `s[i+1]`无法得到分配，结果变小。  
若存在 `s[i] < s[i+1] < g[j] < g[j+1]`，这种情况则按照我们上述方法可以正常分配，不影响结果。

```javascript
/**
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */
var findContentChildren = function (g, s) {
  // 排序 + 贪心
  g.sort((a, b) => a - b);
  s.sort((a, b) => a - b);

  let count = 0; // 结果

  const gLength = g.length,
    sLength = s.length;

  // 为了满足题目要求，尽可能的分配给更多的孩子饼干，我们将大于gi的饼干sj分配给gi就可以了。
  let i = 0,
    j = 0;
  // 孩子分完，或者饼干分完
  while (i < gLength && j < sLength) {
    if (g[i] <= s[j]) {
      count++;
      i++;
    }
    j++;
  }

  return count;
};
```
