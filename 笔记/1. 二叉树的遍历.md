# 二叉树的遍历

## 树的基本结构回顾

- 树的层次计算规则：根结点所在的那一层记为第一层，其子结点所在的就是第二层，以此类推。
- “度”的概念：一个结点开叉出去多少个子树，被记为结点的“度”。比如我们上图中，根结点的“度”就是 3。
- “叶子结点”：叶子结点就是度为 0 的结点。在上图中，最后一层的结点的度全部为 0，所以这一层的结点都是叶子结点。
- 结点和树的“高度”计算规则：叶子结点高度记为 1，每向上一层高度就加 1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度。树中结点的最大高度，称为“树的高度”。

## 二叉树

二叉树是指满足以下要求的树：

它可以没有根结点，作为一棵空树存在
如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树。

注意，二叉树不能被简单定义为每个结点的度都是 2 的树。普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的。对应到图上来看，也就意味着 B 和 C、D 和 E、F 和 G 是不能互换的。

### 二叉树的实现

在 JS 中，二叉树使用对象来定义。它的结构分为三块：

- 数据域
- 左侧子结点（左子树根结点）的引用
- 右侧子结点（右子树根结点）的引用

代码实现：

```javascript
// 二叉树结点构造函数
function TreeNode(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}

// 新增二叉树结点
const node1 = new TreeNode(1);
const node2 = new TreeNode(2);

node1.left = node2; // 将2作为结点1的左子树
```

### 二叉树的遍历

以一定的顺序规则，逐个访问二叉树的所有结点，这个过程就是二叉树的遍历。按照顺序规则的不同，遍历方式有以下四种：

- 先序遍历
- 中序遍历
- 后序遍历
- 层次遍历

按照实现方式的不同，遍历方式又可以分为以下两种：

- 递归遍历（先、中、后序遍历）
- 迭代遍历（层次遍历）

解释一下上面所说的三种次序遍历：

- 根结点 -> 左子树 -> 右子树
- 左子树 -> 根结点 -> 右子树
- 左子树 -> 右子树 -> 根结点

上述三个遍历顺序，就分别对应了二叉树的先序遍历、中序遍历和后序遍历规则。

在这三种顺序中，根结点的遍历分别被安排在了首要位置、中间位置和最后位置。
所谓的“先序”、“中序”和“后序”，“先”、“中”、“后”其实就是指根结点的遍历时机。

在写代码之前，我们先定义好数据：

```javascript
const root = {
  val: "A",
  left: {
    val: "B",
    left: {
      val: "D",
    },
    right: {
      val: "E",
    },
  },
  right: {
    val: "C",
    right: {
      val: "F",
    },
  },
};
```

#### 先序遍历

```javascript
// 递归遍历
function preOrder(root) {
  // 为null了，边界
  if (!root) {
    return;
  }

  console.log("当前遍历的结点:", root.val);
  // 左子树
  preOrder(root.left);
  // 右子树
  preOrder(root.right);
}
```

#### 中序遍历

```javascript
// 递归遍历
function preOrder(root) {
  // 为null了，边界
  if (!root) {
    return;
  }

  // 左子树
  preOrder(root.left);

  console.log("当前遍历的结点:", root.val);

  // 右子树
  preOrder(root.right);
}
```

#### 后序遍历

```javascript
// 递归遍历
function preOrder(root) {
  // 为null了，边界
  if (!root) {
    return;
  }

  // 左子树
  preOrder(root.left);

  // 右子树
  preOrder(root.right);

  console.log("当前遍历的结点:", root.val);
}
```
